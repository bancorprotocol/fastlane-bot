
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Invariants &#8212; FLBTools 1.0+ documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Optimizer" href="optimizer.html" />
    <link rel="prev" title="CPC" href="cpc.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="module-tools.invariants">
<span id="invariants"></span><h1>Invariants<a class="headerlink" href="#module-tools.invariants" title="Permalink to this heading">¶</a></h1>
<p>A collection of tools for analyzing AMM invariant functions</p>
<p>This package contains a collection of tools for analyzing
AMM invariant functions. The focus of this package lies on
AMMs with hyperbolic invariants, ie invariants of the form</p>
<div class="math notranslate nohighlight">
\[x\cdot y = k\]</div>
<p>where k is a constant and x,y are – potentially virtual –
token balances of an AMM. This was the invariant function
used in the first ever AMM, Bancor, and it was taken over by
Uniswap and many others. In levered form it is the invariant
used in Uniswap v3 as well as in Bancor’s Carbon.</p>
<p>The core objects in this package are the <cite>Invariant</cite> and the
<cite>Function</cite> as well as <cite>FunctionVector</cite> objects.</p>
<ul class="simple">
<li><p>the <cite>Invariant</cite> object describes an invariant in the
non-isolated form <span class="math notranslate nohighlight">\(k=k(x,y)\)</span> that is by definition
available for all invariant based AMMs</p></li>
<li><p>the <cite>Function</cite> describes the <em>swap function</em>
<span class="math notranslate nohighlight">\(y=f(x,k)\)</span> that is obtained from the invariant
equation by isolating y, which may or may not be
analytically available for a given invariant.</p></li>
<li><p>the <cite>FunctionVector</cite> object finally describes a vector
of <cite>Function</cite> objects, together with an integration
kernel (see below) thereby effectively defining a vector
space of functions together with a number of norms.</p></li>
</ul>
<p>In addition to those higher level objects, the package also
contains a number of more fundamental objects that are used
as building blocks for those higher level objects. These
include</p>
<ul class="simple">
<li><p>the <cite>Kernel</cite> object represents an <em>integration kernel</em>, ie
a weight function together with a domain of integration;
this object serves to define <span class="math notranslate nohighlight">\(L_p\)</span> norms on the
functions defined above, and therefore ultimately to measure
distances</p></li>
<li><p>the <cite>DictVector</cite> object implements sparse vector
functionality using dicts where the dict keys are
considered the vector space dimensions, and the values
the associated coefficients. Note that any allowable
dict key is a valid dimension.</p></li>
</ul>
<section id="module-tools.invariants.functions">
<span id="functions"></span><h2>Functions<a class="headerlink" href="#module-tools.invariants.functions" title="Permalink to this heading">¶</a></h2>
<p>Represents a function <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">f(x;</span> <span class="pre">params)</span></code> and vectors thereof</p>
<p>This module contains two classes, <code class="docutils literal notranslate"><span class="pre">Function</span></code> and <code class="docutils literal notranslate"><span class="pre">FunctionVector</span></code>.</p>
<ul class="simple">
<li><p>The <code class="docutils literal notranslate"><span class="pre">Function</span></code> class represents a function of the form <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">f(x;</span> <span class="pre">params)</span></code>,
where <code class="docutils literal notranslate"><span class="pre">x</span></code> is the input value and <code class="docutils literal notranslate"><span class="pre">params</span></code> are arbitrary additional
parameters fed into the (data)class upon instantiation.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">FunctionVector</span></code> class represents a vector (linear combination) of
<code class="docutils literal notranslate"><span class="pre">Function</span></code> objects, and implements a function interface (via pointwise
evaluation), a vector interface (from the <code class="docutils literal notranslate"><span class="pre">DictVector</span></code> inheritance). A
<code class="docutils literal notranslate"><span class="pre">FunctionVector</span></code> also contains an integration kernel, which allows it to
expose a number of norms and distance measures.</p></li>
</ul>
<section id="function">
<h3>Function<a class="headerlink" href="#function" title="Permalink to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tools.invariants.functions.Function">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tools.invariants.functions.</span></span><span class="sig-name descname"><span class="pre">Function</span></span><a class="headerlink" href="#tools.invariants.functions.Function" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a function <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">f(x;</span> <span class="pre">params)</span></code></p>
<p>The Function class is an abstract base class that represents an arbitrary
function of the form <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">f(x;</span> <span class="pre">params)</span></code>. The function is inserted into the
object via overriding the <code class="docutils literal notranslate"><span class="pre">f</span></code> method, and the parameters are inserted via
the (data)class constructor. The class also exposes a number of methods and
properties that are useful for analyzing the function, notably the first
and second derivate and the so-called price function <span class="math notranslate nohighlight">\(p(x) = -f'(x)\)</span>.</p>
<p>The below example shows how to implement the function</p>
<div class="math notranslate nohighlight">
\[f_k(x) = \left(\sqrt{1+x} - 1\right)*k\]</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">functions</span> <span class="k">as</span> <span class="nn">f</span>

<span class="nd">@f</span><span class="o">.</span><span class="n">dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">MyFunction</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">MyFunction</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">mf</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>           <span class="c1"># 0.4142</span>
<span class="n">mf</span><span class="o">.</span><span class="n">p</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>         <span class="c1"># 0.3536</span>
<span class="n">mf</span><span class="o">.</span><span class="n">df_dx</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>     <span class="c1"># -0.3536</span>
<span class="n">mf</span><span class="o">.</span><span class="n">pp</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>        <span class="c1"># -0.0883</span>
</pre></div>
</div>
<p>For functions where we know the derivatives analytically, we can override
the <code class="docutils literal notranslate"><span class="pre">p</span></code> and <code class="docutils literal notranslate"><span class="pre">pp</span></code> methods (we should not usually touch <code class="docutils literal notranslate"><span class="pre">df_dx</span></code> as it refers
back to <code class="docutils literal notranslate"><span class="pre">p</span></code> in a trivial manner). The below implements a simple hyperbolic
function to the type found in an AMM:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">functions</span> <span class="k">as</span> <span class="nn">f</span>

<span class="nd">@f</span><span class="o">.</span><span class="n">dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">HyperbolaFunction</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">Function</span><span class="p">):</span>

    <span class="n">k</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">/</span><span class="n">x</span>

    <span class="k">def</span> <span class="nf">p</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that we are using <em>frozen</em> dataclasses here which allows us to use those
functions as keys in a dict, which we will make use of in the <cite>FunctionVector</cite>
class derived. If you need to change an attribute in a frozen class you can
do so using the following trick:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>     <span class="c1"># changes k to 2 despite the class being frozen</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.d2f_dx2_abs">
<span class="sig-name descname"><span class="pre">d2f_dx2_abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.d2f_dx2_abs" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates the second derivative of <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> at <code class="docutils literal notranslate"><span class="pre">x</span></code> with abs step size h*precision</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.d2f_dx2_rel">
<span class="sig-name descname"><span class="pre">d2f_dx2_rel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.d2f_dx2_rel" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates the second derivative of <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> at <code class="docutils literal notranslate"><span class="pre">x</span></code> with relative step size eta (<code class="docutils literal notranslate"><span class="pre">h=x*eta*precision</span></code>)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.df_dx">
<span class="sig-name descname"><span class="pre">df_dx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.df_dx" title="Permalink to this definition">¶</a></dt>
<dd><p>first derivative (alias  for <code class="docutils literal notranslate"><span class="pre">-p</span></code>)</p>
<p>note: this function calls <code class="docutils literal notranslate"><span class="pre">p</span></code> and it should not be overridden</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.df_dx_abs">
<span class="sig-name descname"><span class="pre">df_dx_abs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.df_dx_abs" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates the derivative of <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> at <code class="docutils literal notranslate"><span class="pre">x</span></code> with abs step size h*precision</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.df_dx_rel">
<span class="sig-name descname"><span class="pre">df_dx_rel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.df_dx_rel" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates the derivative of <code class="docutils literal notranslate"><span class="pre">f(x)</span></code> at <code class="docutils literal notranslate"><span class="pre">x</span></code> with relative step size eta (<code class="docutils literal notranslate"><span class="pre">h=x*eta*precision</span></code>)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.f">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">f</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.f" title="Permalink to this definition">¶</a></dt>
<dd><p>returns <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">f(x;</span> <span class="pre">k)</span></code> [to be implemented by subclass]</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> – input value x (token balance)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>output value y (other token balance)</p>
</dd>
</dl>
<p>this function must be implemented by the subclass as
it specifies the actual function other parameters –
notably the pool constant <code class="docutils literal notranslate"><span class="pre">k</span></code> – will usually be parts
of the (dataclass) constructor</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.p">
<span class="sig-name descname"><span class="pre">p</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.p" title="Permalink to this definition">¶</a></dt>
<dd><p>price function (alias for <code class="docutils literal notranslate"><span class="pre">-df_dx_xxx</span></code>)</p>
<p>Note: this function CAN be overridden by the subclass if it can be
calculated analytically in this case the precision parameter should be
ignored</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.p_func">
<span class="sig-name descname"><span class="pre">p_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.p_func" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the derivative as a function object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.params">
<span class="sig-name descname"><span class="pre">params</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.params" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the parameters of the function as a dictionary</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.pp">
<span class="sig-name descname"><span class="pre">pp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.pp" title="Permalink to this definition">¶</a></dt>
<dd><p>derivative of the price function (alias for <code class="docutils literal notranslate"><span class="pre">-d2f_dx2_xxx</span></code>)</p>
<p>Note: this function does not call <cite>p</cite> but goes via <code class="docutils literal notranslate"><span class="pre">d2f_dx2_xxx</span></code>; if <code class="docutils literal notranslate"><span class="pre">p</span></code>
is overrriden then it may make sense to override this function as well</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.pp_func">
<span class="sig-name descname"><span class="pre">pp_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.pp_func" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the second derivative as a function object</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.Function.update">
<span class="sig-name descname"><span class="pre">update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.Function.update" title="Permalink to this definition">¶</a></dt>
<dd><p>returns a copy of the function, with the given parameters updated</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>kwargs</strong> – parameters to update</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="functionvector">
<h3>FunctionVector<a class="headerlink" href="#functionvector" title="Permalink to this heading">¶</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tools.invariants.functions.</span></span><span class="sig-name descname"><span class="pre">FunctionVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#tools.invariants.kernel.Kernel" title="tools.invariants.kernel.Kernel"><span class="pre">Kernel</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector" title="Permalink to this definition">¶</a></dt>
<dd><p>a vector of functions</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>kernel</strong> – the integration kernel to use (default: Kernel())</p>
</dd>
</dl>
<p>A function vector is a linear combination of Function objects. It exposes
the usual <strong>vector properties</strong> (technically it is a <cite>DictVector</cite> subclass) where
the functions themselves used as dict keys and therefore the <em>dimensions</em> of the
vector space. Note that there is an additional constraint the only vectors that
have the same kernel can be aggregated.</p>
<p>It also exposes properties related to <strong>pointwise evaluation</strong> of the functions, notably
the function value of the vector at point x is given as</p>
<div class="math notranslate nohighlight">
\[f_v(x) = \sum_i \alpha_i * f_i(x)\]</div>
<p>and this carries over to the price functions an derivatives that are exposed
in the <code class="docutils literal notranslate"><span class="pre">p</span></code>, <code class="docutils literal notranslate"><span class="pre">df_dx</span></code>, <code class="docutils literal notranslate"><span class="pre">pp</span></code> etc methods.</p>
<p>Finally it exposes properties related to <strong>integration</strong> of the functions
based on the kernel, notably the <cite>integrate</cite> method that integrates the
vector of functions as well as various norms and distance measures.</p>
<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.apply_kernel">
<span class="sig-name descname"><span class="pre">apply_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.apply_kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>returns <code class="docutils literal notranslate"><span class="pre">func</span></code> multiplied by the kernel value (as value or lambda if <code class="docutils literal notranslate"><span class="pre">x</span></code> is None)</p>
<p>USAGE</p>
<p>this function can either be called directly</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fv</span> <span class="o">=</span> <span class="n">FunctionVector</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">fv</span><span class="o">.</span><span class="n">apply_kernel</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c1"># ==&gt; value</span>
</pre></div>
</div>
<p>or be used to create a new function</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fv</span> <span class="o">=</span> <span class="n">FunctionVector</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">func_kernel</span> <span class="o">=</span> <span class="n">fv</span><span class="o">.</span><span class="n">apply_kernel</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="c1"># ==&gt; lambda</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.bump">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">bump</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dct</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.bump" title="Permalink to this definition">¶</a></dt>
<dd><p>bumps <code class="docutils literal notranslate"><span class="pre">dct[k]</span></code> by <code class="docutils literal notranslate"><span class="pre">+h</span></code>; everything else unmodified (returns a new dict)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.curve_fit">
<span class="sig-name descname"><span class="pre">curve_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.curve_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>fits a function to self using gradient descent</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – function to fit (typically a Function object) (1)</p></li>
<li><p><strong>params0</strong> – starting parameters (dict) (1)</p></li>
<li><p><strong>kwargs</strong> – passed to self.minimize</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the parameters of the fitted function (dict)</p>
</dd>
</dl>
<p>NOTE1: The <code class="docutils literal notranslate"><span class="pre">func</span></code> object must have an <code class="docutils literal notranslate"><span class="pre">update</span></code> method that accepts a dict of
parameters with the keys of <code class="docutils literal notranslate"><span class="pre">params0</span></code> and returns a new object with the updated
parameters.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.df_dx">
<span class="sig-name descname"><span class="pre">df_dx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.df_dx" title="Permalink to this definition">¶</a></dt>
<dd><p>derivative of <code class="docutils literal notranslate"><span class="pre">self.f</span></code> (alias for <code class="docutils literal notranslate"><span class="pre">-p</span></code>)</p>
<div class="math notranslate nohighlight">
\[\frac{df}{dx}(x) = \sum_i \alpha_i * \frac{df_i}{dx}(x)\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.distance">
<span class="sig-name descname"><span class="pre">distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.distance" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates the distance between <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">func</span></code> (L2 norm)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.distance2">
<span class="sig-name descname"><span class="pre">distance2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.distance2" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates the distance^2 between <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">func</span></code> (L2 norm)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.e_i">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">e_i</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.e_i" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the <code class="docutils literal notranslate"><span class="pre">i</span></code>’th unit vector of size <code class="docutils literal notranslate"><span class="pre">n</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.e_k">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">e_k</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dct</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.e_k" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the unit vector of key <code class="docutils literal notranslate"><span class="pre">k</span></code> in <code class="docutils literal notranslate"><span class="pre">dct</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.f">
<span class="sig-name descname"><span class="pre">f</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.f" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the function value</p>
<div class="math notranslate nohighlight">
\[f(x) = \sum_i \alpha_i * f_i(x)\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.f_k">
<span class="sig-name descname"><span class="pre">f_k</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.f_k" title="Permalink to this definition">¶</a></dt>
<dd><p>alias for <code class="docutils literal notranslate"><span class="pre">self.apply_kernel(self.f,</span> <span class="pre">x)</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.f_r">
<span class="sig-name descname"><span class="pre">f_r</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.f_r" title="Permalink to this definition">¶</a></dt>
<dd><p>alias for <code class="docutils literal notranslate"><span class="pre">self.restricted(self.f,</span> <span class="pre">x)</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.goalseek">
<span class="sig-name descname"><span class="pre">goalseek</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.goalseek" title="Permalink to this definition">¶</a></dt>
<dd><p>very simple gradient descent implementation for a goal seek</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>target</strong> – target value (default: 0)</p></li>
<li><p><strong>x0</strong> – starting estimate</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.integrate">
<span class="sig-name descname"><span class="pre">integrate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>integrates <code class="docutils literal notranslate"><span class="pre">`self.f`</span></code> using the kernel [convenience access for <code class="docutils literal notranslate"><span class="pre">integrate_func(func=None)</span></code>]</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.integrate_func">
<span class="sig-name descname"><span class="pre">integrate_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.integrate_func" title="Permalink to this definition">¶</a></dt>
<dd><p>integrates <code class="docutils literal notranslate"><span class="pre">func</span></code> (default: <code class="docutils literal notranslate"><span class="pre">self.f</span></code>) using the kernel</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.minimize">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">minimize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learning_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">deriv_h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_path</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.minimize" title="Permalink to this definition">¶</a></dt>
<dd><p>minimizes the function <code class="docutils literal notranslate"><span class="pre">func</span></code> using gradient descent (multiple dimensions)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – function to be minimized</p></li>
<li><p><strong>x0</strong> – starting point (<code class="docutils literal notranslate"><span class="pre">np.array</span></code>-like or dct (1))</p></li>
<li><p><strong>learning_rate</strong> – optimization parameter (float; default <code class="docutils literal notranslate"><span class="pre">cls.MM_LEARNING_RATE</span></code>)</p></li>
<li><p><strong>iterations</strong> – max iterations (int; default <code class="docutils literal notranslate"><span class="pre">cls.MM_ITERATIONS</span></code>)</p></li>
<li><p><strong>tolerance</strong> – convergence tolerance (float; default <code class="docutils literal notranslate"><span class="pre">cls.MM_TOLERANCE</span></code>)</p></li>
<li><p><strong>deriv_h</strong> – step size for derivative calculation (float; default <code class="docutils literal notranslate"><span class="pre">cls.MM_DERIV_H</span></code>)</p></li>
<li><p><strong>return_path</strong> – if True, returns the entire optimization path (list of <code class="docutils literal notranslate"><span class="pre">np.array</span></code>)
as well as the last dfdx (<code class="docutils literal notranslate"><span class="pre">np.array</span></code>); in this case, the result is
the last element of the path</p></li>
</ul>
</dd>
</dl>
<p>NOTE1: if <cite>x0</cite> is <code class="docutils literal notranslate"><span class="pre">np.array</span></code>-like or <code class="docutils literal notranslate"><span class="pre">None</span></code>, then <cite>func</cite> will be called with
positional arguments and the result will be returned as an <code class="docutils literal notranslate"><span class="pre">np.array</span></code>. If <code class="docutils literal notranslate"><span class="pre">x0</span></code>
is a dict, then <code class="docutils literal notranslate"><span class="pre">func</span></code> will be called with keyword arguments and the result
will be returned as a dict</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.minimize1">
<span class="sig-name descname"><span class="pre">minimize1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learning_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.minimize1" title="Permalink to this definition">¶</a></dt>
<dd><p>minimizes the function using gradient descent</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> – starting estimate (float)</p></li>
<li><p><strong>learning_rate</strong> – optimization parameter (float; default <code class="docutils literal notranslate"><span class="pre">cls.MM_LEARNING_RATE</span></code>)</p></li>
<li><p><strong>iterations</strong> – max iterations (int; default <code class="docutils literal notranslate"><span class="pre">cls.MM_ITERATIONS</span></code>)</p></li>
<li><p><strong>tolerance</strong> – convergence tolerance (float; <code class="docutils literal notranslate"><span class="pre">default</span> <span class="pre">cls.MM_TOLERANCE</span></code>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates the norm of <code class="docutils literal notranslate"><span class="pre">self</span></code> (L2 norm)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.norm2">
<span class="sig-name descname"><span class="pre">norm2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.norm2" title="Permalink to this definition">¶</a></dt>
<dd><p>calculates the norm^2 of <code class="docutils literal notranslate"><span class="pre">self</span></code> (L2 norm)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.p">
<span class="sig-name descname"><span class="pre">p</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.p" title="Permalink to this definition">¶</a></dt>
<dd><p>returns <span class="math notranslate nohighlight">\(\sum_i \alpha_i * p_i(x)\)</span> where <span class="math notranslate nohighlight">\(p_i\)</span> is the price function of <span class="math notranslate nohighlight">\(f_i\)</span></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">title</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xlabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ylabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>plots the function</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – function to plot (default: <code class="docutils literal notranslate"><span class="pre">self.f_r</span></code>)</p></li>
<li><p><strong>x_min</strong> – lower bound (default: <code class="docutils literal notranslate"><span class="pre">self.kernel.x_min</span></code>)</p></li>
<li><p><strong>x_max</strong> – upper bound (default: <code class="docutils literal notranslate"><span class="pre">self.kernel.x_max</span></code>)</p></li>
<li><p><strong>steps</strong> – number of steps (default: <code class="docutils literal notranslate"><span class="pre">np.linspace</span></code> defaults)</p></li>
<li><p><strong>show</strong> – whether to call plt.show() (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p></li>
<li><p><strong>grid</strong> – whether to show a grid (default: <code class="docutils literal notranslate"><span class="pre">True</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the result of <code class="docutils literal notranslate"><span class="pre">plt.plot</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.pp">
<span class="sig-name descname"><span class="pre">pp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.pp" title="Permalink to this definition">¶</a></dt>
<dd><p>derivative of the price function of <code class="docutils literal notranslate"><span class="pre">self.f</span></code></p>
<div class="math notranslate nohighlight">
\[pp(x) = \sum_i \alpha_i * pp_i(x)\]</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.restricted">
<span class="sig-name descname"><span class="pre">restricted</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.restricted" title="Permalink to this definition">¶</a></dt>
<dd><p>returns <code class="docutils literal notranslate"><span class="pre">func(x)</span></code> restricted to the domain of <code class="docutils literal notranslate"><span class="pre">self.kernel</span></code> (as value or lambda if <code class="docutils literal notranslate"><span class="pre">x</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p>
<p>USAGE</p>
<p>this function can either be called directly</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fv</span> <span class="o">=</span> <span class="n">FunctionVector</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">fv</span><span class="o">.</span><span class="n">restricted</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="c1"># ==&gt; value</span>
</pre></div>
</div>
<p>or be used to create a new function</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fv</span> <span class="o">=</span> <span class="n">FunctionVector</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">func_restricted</span> <span class="o">=</span> <span class="n">fv</span><span class="o">.</span><span class="n">restricted</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="c1"># ==&gt; lambda</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.functions.FunctionVector.wrap">
<span class="sig-name descname"><span class="pre">wrap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.functions.FunctionVector.wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>creates a FunctionVector from a function using the same kernel as self</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>func</strong> – the function to wrap (a Function object)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a new FunctionVector object wrapping <cite>fu`nc</cite>, with the same kernel as <code class="docutils literal notranslate"><span class="pre">self</span></code></p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">fv0</span> <span class="o">=</span> <span class="n">FunctionVector</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span><span class="n">mykernel</span><span class="p">)</span>       <span class="c1"># creates a FV with a specific kernel</span>
<span class="n">f</span>   <span class="o">=</span> <span class="n">MyFunction</span><span class="p">()</span>                          <span class="c1"># creates a Function object</span>
<span class="n">fv0</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>                                 <span class="c1"># a FV object with the same kernel as fv0</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
</section>
<section id="module-tools.invariants.invariant">
<span id="invariant"></span><h2>Invariant<a class="headerlink" href="#module-tools.invariants.invariant" title="Permalink to this heading">¶</a></h2>
<p>Represents an AMM invariant</p>
<p>An AMM invariant is a function <span class="math notranslate nohighlight">\(k(x, y)\)</span> that is constant for all x, y in
the AMM, typically expressed in a form like <span class="math notranslate nohighlight">\(x\cdot y = k\)</span>. This is
distinct from the swap function <span class="math notranslate nohighlight">\(y=f(x, k)\)</span> which is obtained from the
invariant by isolating y.</p>
<p>Usually working with the swap function is more convenient. However, in some cases
the invariant can be computed analytically whilst the swap function can not. The
<code class="docutils literal notranslate"><span class="pre">Invariant</span></code> class – which is the core class of this module – allows amongst other
things to estimate the swap function numerically rather than having to solve for
it analytically which may not always be possible.</p>
<dl class="py class">
<dt class="sig sig-object py" id="tools.invariants.invariant.Invariant">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tools.invariants.invariant.</span></span><span class="sig-name descname"><span class="pre">Invariant</span></span><a class="headerlink" href="#tools.invariants.invariant.Invariant" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents an AMM invariant</p>
<p>This class is an abstract base class that represents an arbitrary AMM invariant. In order
to obtain a usuable invariant object, one must subclass this class and implement the
<code class="docutils literal notranslate"><span class="pre">k_func</span></code> method. For example the following code snippet shows how to implement a simple
constant product invariant:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ConstantProductInvariant</span><span class="p">(</span><span class="n">Invariant</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">k_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span>

<span class="n">cpi</span> <span class="o">=</span> <span class="n">ConstantProductInvariant</span><span class="p">()</span>
<span class="n">cpi</span><span class="o">.</span><span class="n">y_func</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>  <span class="c1"># returns ~5 (calculated numerically)</span>
</pre></div>
</div>
<p>The constant product invariant is analytically very easy to handle, and therefore a better
implementation would be to also implement the <code class="docutils literal notranslate"><span class="pre">y_Func</span></code> method, which returns the swap function
as a <code class="docutils literal notranslate"><span class="pre">Function</span></code> object. This is shown in the following code snippet:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ConstantProductSwapFunction</span><span class="p">(</span><span class="n">Function</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">/</span> <span class="n">x</span>

<span class="k">class</span> <span class="nc">ConstantProductInvariant2</span><span class="p">(</span><span class="n">Invariant</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">k_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span>

    <span class="n">YFUNC_CLASS</span> <span class="o">=</span> <span class="n">ConstantProductSwapFunction</span>

<span class="n">cpi</span> <span class="o">=</span> <span class="n">ConstantProductInvariant2</span><span class="p">()</span>
<span class="n">cpi</span><span class="o">.</span><span class="n">y_func</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>  <span class="c1"># returns 5 (calculated analytically)</span>
</pre></div>
</div>
<dl class="py exception">
<dt class="sig sig-object py" id="tools.invariants.invariant.Invariant.ConvergenceError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ConvergenceError</span></span><a class="headerlink" href="#tools.invariants.invariant.Invariant.ConvergenceError" title="Permalink to this definition">¶</a></dt>
<dd><p>raised when a goal seek fails to converge</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.invariant.Invariant.goalseek_bisect">
<span class="sig-name descname"><span class="pre">goalseek_bisect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_lo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_hi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.invariant.Invariant.goalseek_bisect" title="Permalink to this definition">¶</a></dt>
<dd><p>bisect implementation for goal seek</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – function for goal seek, eg <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">x:</span> <span class="pre">x**2-1</span></code></p></li>
<li><p><strong>target</strong> – target value (default: 0)</p></li>
<li><p><strong>x_lo</strong> – lower bound on x (default: GSBS_XLO=1e-10)</p></li>
<li><p><strong>x_hi</strong> – upper bound on x (default: GSBS_XHI=1e10)</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">ConvergenceError</span></code> if it fails to converge</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">x</span></code> such that <code class="docutils literal notranslate"><span class="pre">func(x)</span></code> is close to target</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.invariant.Invariant.goalseek_gradient">
<span class="sig-name descname"><span class="pre">goalseek_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.invariant.Invariant.goalseek_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>very simple gradient descent implementation for a goal seek</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – function for goal seek, eg <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">x:</span> <span class="pre">x**2-1</span></code></p></li>
<li><p><strong>target</strong> – target value (default: 0)</p></li>
<li><p><strong>x0</strong> – starting estimate</p></li>
</ul>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="docutils literal notranslate"><span class="pre">ConvergenceError</span></code> if it fails to converge</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="docutils literal notranslate"><span class="pre">x</span></code> such that <code class="docutils literal notranslate"><span class="pre">func(x)</span></code> is close to target</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.invariant.Invariant.k_func">
<em class="property"><span class="pre">abstract</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">k_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.invariant.Invariant.k_func" title="Permalink to this definition">¶</a></dt>
<dd><p>returns invariant value k = k(x, y)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.invariant.Invariant.p_func">
<span class="sig-name descname"><span class="pre">p_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.invariant.Invariant.p_func" title="Permalink to this definition">¶</a></dt>
<dd><p>returns p = -dy/dx = p(x, k)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – token balance x</p></li>
<li><p><strong>k</strong> – pool invariant k</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>price function p = -y’(x, k) (1)</p>
</dd>
</dl>
<p>NOTE 1: this currently only works if y_func is analytic, in which case
the value returned is <code class="docutils literal notranslate"><span class="pre">self.y_Func(k=k).p(x)</span></code></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.invariant.Invariant.y_Func">
<span class="sig-name descname"><span class="pre">y_Func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.invariant.Invariant.y_Func" title="Permalink to this definition">¶</a></dt>
<dd><p>returns y = y(x=.; k) as a Function object (may also return None)</p>
<p>USAGE</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">y_func</span> <span class="o">=</span> <span class="n">y_Func</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">y_func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.invariant.Invariant.y_func">
<span class="sig-name descname"><span class="pre">y_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.invariant.Invariant.y_func" title="Permalink to this definition">¶</a></dt>
<dd><p>returns y = y(x,k)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> – token balance x</p></li>
<li><p><strong>k</strong> – pool invariant k</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>token balance y = y(x, k) (1)</p>
</dd>
</dl>
<p>NOTE 1: y is calculated from <code class="docutils literal notranslate"><span class="pre">y_Func</span></code> if possible or numerically via
<code class="docutils literal notranslate"><span class="pre">y_func_from_k_func</span></code> otherwise</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.invariant.Invariant.y_func_from_k_func">
<span class="sig-name descname"><span class="pre">y_func_from_k_func</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_lo</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_hi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.invariant.Invariant.y_func_from_k_func" title="Permalink to this definition">¶</a></dt>
<dd><p>solves y = y(x, k) from k = k(x, y)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> – starting estimate (for gradient, default = 1)</p></li>
<li><p><strong>x_hi</strong> – upper bound (for bisect, default = 1e10)</p></li>
<li><p><strong>x_lo</strong> – ditto lower (default = 1e-10)</p></li>
<li><p><strong>method</strong> – one of GS_GRADIENT (default) or GS_BISECT</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tools.invariants.invariant.Invariant.y_func_is_analytic">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">y_func_is_analytic</span></span><a class="headerlink" href="#tools.invariants.invariant.Invariant.y_func_is_analytic" title="Permalink to this definition">¶</a></dt>
<dd><p>whether y_func is obtained as an analytic calculation (ie, not via y_func_from_k_func)</p>
</dd></dl>

</dd></dl>

</section>
<section id="helpers">
<h2>Helpers<a class="headerlink" href="#helpers" title="Permalink to this heading">¶</a></h2>
<section id="module-tools.invariants.vector">
<span id="vector"></span><h3>Vector<a class="headerlink" href="#module-tools.invariants.vector" title="Permalink to this heading">¶</a></h3>
<p>Implements the <code class="docutils literal notranslate"><span class="pre">DictVector</span></code> class, a sparse vector based on dicts</p>
<dl class="py class">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tools.invariants.vector.</span></span><span class="sig-name descname"><span class="pre">DictVector</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.vector.DictVector" title="Permalink to this definition">¶</a></dt>
<dd><p>A sparse vector where dict keys are dimensions and values are coefficients</p>
<p>USAGE</p>
<p>below an incomplete list of operations that can be performed; note that most
dunder methods are actually implemented, so the usual arithmetic operations
can be performed</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">v1</span> <span class="o">=</span> <span class="n">DictVector</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>      <span class="c1"># use kwargs</span>

<span class="n">d2</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">30</span><span class="p">)</span>
<span class="n">v2</span> <span class="o">=</span> <span class="n">DictVector</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">d2</span><span class="p">)</span>                 <span class="c1"># use dict</span>

<span class="n">v1</span><span class="o">+</span><span class="n">v2</span>                                   <span class="c1"># {a: 11, b: 22, c: 33}</span>
<span class="n">v2</span><span class="o">-</span><span class="n">v1</span>                                   <span class="c1"># {a: 9, b: 18, c: 27}</span>
<span class="mi">2</span><span class="o">*</span><span class="n">v1</span>                                    <span class="c1"># {a: 2, b: 4, c: 6}</span>
<span class="n">v1</span><span class="o">.</span><span class="n">enorm</span>                                <span class="c1"># = sqrt(1+4+9) ~ 3.74</span>
<span class="n">v1</span> <span class="o">==</span> <span class="n">v2</span>                                <span class="c1"># False</span>
<span class="nb">len</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>                                 <span class="c1"># 3</span>

<span class="n">v</span> <span class="o">=</span> <span class="n">DictVector</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">v</span> <span class="o">+=</span> <span class="n">v1</span>
<span class="n">v</span> <span class="o">==</span> <span class="n">DictVector</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># True</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector.dict_add">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict_add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.vector.DictVector.dict_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds two dict-vectors <cite>a</cite> and <cite>b</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector.dict_eq">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict_eq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.vector.DictVector.dict_eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates whether two dict-vectors <cite>a</cite> and <cite>b</cite> are equal (within <cite>eps</cite>, on absolute value basis)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector.dict_norm">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.vector.DictVector.dict_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Euclidian norm of dict-vector <cite>a</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector.dict_smul">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict_smul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.vector.DictVector.dict_smul" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplies dict-vector <cite>a</cite> by scalar <cite>s</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector.dict_sprod">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict_sprod</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.vector.DictVector.dict_sprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplies two dict-vectors <cite>a</cite> and <cite>b</cite> (scalar product)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector.dict_sub">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dict_sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.vector.DictVector.dict_sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtracts two dict-vectors <cite>a</cite> and <cite>b</cite></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector.enorm">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">enorm</span></span><a class="headerlink" href="#tools.invariants.vector.DictVector.enorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns Euclidian norm of <cite>self</cite></p>
<div class="math notranslate nohighlight">
\[n_e = \sqrt{\sum_i \alpha_i^2}\]</div>
<p>EXAMPLE</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">v</span> <span class="o">=</span> <span class="n">DictVector</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">v</span><span class="o">.</span><span class="n">enorm</span>                         <span class="c1"># = sqrt(3^2 + 4^2) = 5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector.n">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">single_dict_argument</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.vector.DictVector.n" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new DictVector from <cite>kwargs</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector.new">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">new</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">single_dict_argument</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.vector.DictVector.new" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new DictVector from <cite>kwargs</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.vector.DictVector.null">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">null</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.vector.DictVector.null" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a <em>null</em> DictVector, aka an empty dict</p>
</dd></dl>

</dd></dl>

</section>
<section id="module-tools.invariants.kernel">
<span id="kernel"></span><h3>Kernel<a class="headerlink" href="#module-tools.invariants.kernel" title="Permalink to this heading">¶</a></h3>
<p>Implements the <cite>Kernel</cite> class, an integration kernel together with numeric integration code</p>
<dl class="py class">
<dt class="sig sig-object py" id="tools.invariants.kernel.Kernel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">tools.invariants.kernel.</span></span><span class="sig-name descname"><span class="pre">Kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_min</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_max</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">callable</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'builtin-flat'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'trapezoid'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.kernel.Kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a one-dimensional integration kernel and provides numeric integration code</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_min</strong> – minimum x value for integration</p></li>
<li><p><strong>x_max</strong> – ditto maximum</p></li>
<li><p><strong>kernel</strong> – kernel function (should be positive, and defined <cite>x_min</cite> &lt;= <cite>x</cite> &lt;= <cite>x_max</cite>);
generically, the kernel function is a callable taking a single argument;
alternatively there are a number of built-in kernels that can be selected
by passing the respective constant (see table)</p></li>
<li><p><strong>method</strong> – integration method (currently only <cite>METHOD_TRAPEZOID</cite>)</p></li>
<li><p><strong>steps</strong> – number of steps for integration</p></li>
</ul>
</dd>
</dl>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p><cite>kernel</cite></p></th>
<th class="head"><p>meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>FLAT</p></td>
<td><p>constant</p></td>
</tr>
<tr class="row-odd"><td><p>TRIANGLE</p></td>
<td><p>triangle</p></td>
</tr>
<tr class="row-even"><td><p>SAWTOOTHL, SAWTOOTHR</p></td>
<td><p>sawtooth left/right</p></td>
</tr>
<tr class="row-odd"><td><p>GAUSS, GAUSSW, GAUSSN</p></td>
<td><p>gaussian (fitted, wide, narrow)</p></td>
</tr>
</tbody>
</table>
<p>USAGE</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">k</span> <span class="o">=</span> <span class="n">Kernel</span><span class="p">(</span><span class="n">x_min</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">Kernel</span><span class="o">.</span><span class="n">FLAT</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>

<span class="n">k</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>                  <span class="c1"># 0.5</span>
<span class="n">k</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>          <span class="c1"># ~0.6666</span>

<span class="n">Kernel</span><span class="o">.</span><span class="n">integrate_trapezoid</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1"># ~0.6666</span>
</pre></div>
</div>
<dl class="py property">
<dt class="sig sig-object py" id="tools.invariants.kernel.Kernel.domain">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">domain</span></span><a class="headerlink" href="#tools.invariants.kernel.Kernel.domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience accessor for <cite>(x_min, x_max)</cite></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.kernel.Kernel.in_domain">
<span class="sig-name descname"><span class="pre">in_domain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.kernel.Kernel.in_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True iff x is in the integration domain <cite>x_min</cite>…`x_max`</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.kernel.Kernel.integrate">
<span class="sig-name descname"><span class="pre">integrate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.kernel.Kernel.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrates <cite>func</cite> against the kernel (calls <cite>integrate_trapezoid</cite>)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – function to integrate (single variable)</p></li>
<li><p><strong>steps</strong> – number of steps for integration (default: self.steps)</p></li>
<li><p><strong>method</strong> – integration method (default: self.method) (1)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(\int_{x_{min}}^{x_{max}} \mathrm{func}(x)\,\mathrm{kernel}(x)\,dx\)</span></p>
</dd>
</dl>
<p>NOTE 1: currently the only method supported is <cite>METHOD_TRAPEZOID</cite></p>
<p>EXAMPLE</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">k</span> <span class="o">=</span> <span class="n">Kernel</span><span class="p">(</span><span class="n">x_min</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_max</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span><span class="n">Kernel</span><span class="o">.</span><span class="n">FLAT</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
<span class="n">k</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>          <span class="c1"># ~0.6666</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.kernel.Kernel.integrate_trapezoid">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">integrate_trapezoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.kernel.Kernel.integrate_trapezoid" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrates a function using the trapezoid method between <cite>x_min</cite> and <cite>x_max</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – function to integrate (single variable callable)</p></li>
<li><p><strong>x_min</strong> – minimum x value for integration</p></li>
<li><p><strong>x_max</strong> – ditto maximum</p></li>
<li><p><strong>steps</strong> – number of steps for integration</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><span class="math notranslate nohighlight">\(\int_{x_{min}}^{x_{max}} \mathrm{func}(x)\,dx\)</span></p>
</dd>
</dl>
<p>EXAMPLE</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>
<span class="n">Kernel</span><span class="o">.</span><span class="n">integrate_trapezoid</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1"># ~0.6666</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="tools.invariants.kernel.Kernel.k">
<span class="sig-name descname"><span class="pre">k</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#tools.invariants.kernel.Kernel.k" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for <cite>self.kernel(x)</cite>, but set to zero beyond <cite>x_min</cite>, <cite>x_max</cite></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="tools.invariants.kernel.Kernel.limits">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">limits</span></span><a class="headerlink" href="#tools.invariants.kernel.Kernel.limits" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience accessor for <cite>(x_min, x_max)</cite></p>
</dd></dl>

</dd></dl>

</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">FLBTools</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="analyzer.html">Analyzer</a></li>
<li class="toctree-l1"><a class="reference internal" href="arbgraphs.html">ArbGraphs</a></li>
<li class="toctree-l1"><a class="reference internal" href="cpc.html">CPC</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Invariants</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-tools.invariants.functions">Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#function">Function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#functionvector">FunctionVector</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-tools.invariants.invariant">Invariant</a></li>
<li class="toctree-l2"><a class="reference internal" href="#helpers">Helpers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-tools.invariants.vector">Vector</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-tools.invariants.kernel">Kernel</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="optimizer.html">Optimizer</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="cpc.html" title="previous chapter">CPC</a></li>
      <li>Next: <a href="optimizer.html" title="next chapter">Optimizer</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;Bprotocol foundation 2023-24.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/invariants.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>